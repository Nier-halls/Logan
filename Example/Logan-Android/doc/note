
=====2019-02-18 19:35:43=====
1.loadLibrary为什么要用Runntime的library，和System.loadLibrary有什么区别吗?
2.JNI方法中jobject对象代表的是什么?
3.CMakeList的基本语法? c代码是怎么实现互相依赖的? 也没有看到有inClude代码的地方?
4.JNI方法的前缀为什么会有一个符号"1"
5.mmap的简单用法?

=====2019-02-20 10:11:24=====

疑问：
1.logan_init中有没有涉及到mmap相关的配置，mmap配置需要做一些什么
A:创建了mmap文件，并且填充了空数据，大小为150。目前不清楚这个缓存文件是怎么使用的。

2.Linux中用户群组的概念是什么？普通app代表的用户属于什么群组？
3.Linux中文件描述符到底是什么？
A:打开文件后的一个标志，可以类比AMS在新启动一个activity后返回给ActivityThread的一个Token(Binder)用于跨进程(跨内核态)找到指定的文件。文件描述符存在进程描述文件task_struct中(task_struce -> file_struct -> fds)


笔记：
1.c(c++)中'*'代表取一个地址指向的值，一般*p=&x
2.'*'指针类型的引用值永远是一个地址，之所以声明指针的类型是方便*运算符直接取值。指针可以理解为一个特殊的变量，存的是地址，却拥有根据地址获取值的能力。
3.c(c++)中'&'代表取一个引用的地址, int i=10, &i 取存10整形的地址
4.NULL代码void*类型(类似于Object类型的指针)的引用，地址值为0,也就是((void*)0)
5.memset(cache_path, 0, total); memset初始化内存地址，给初始地址为cache_path的地址便宜到total为止都置为0
6.memcpy(KEY, key, 16); memcpy，拷贝指定内存长度，从key拷贝到KEY中
7.				/**
				 * mmap参数 
				 *
				 * addr mmap内存映射到的地址，如果传NULL由内核自己决定映射到哪里
				 * length 需要映射的文件长度
				 * prot mapping映射的权限
				 * flags 映射后更新会同时生效到文件显示在别的进程中的映射
				 * fd 需要mmap的文件描述符
				 * offset 映射的偏移量
				 */
                p_map = (unsigned char *) mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);

总结：
logan-init
1.logan分为java层和native层，大部分操作都是在native层完成的
2.java层的操作会被封装成LoganModel对象然后放到一个全局的集合中等待处理（这一块为什么不能直接封装成一个子线程的handler来处理）
*线程轮询这块逻辑感觉挺复杂的，互相加锁，需要研究一下为什么需要这么多层的锁，需要await和notify，能直接poll来阻塞吗？
*这一块能否参照线程池的方案来做优化，不要用太多的锁。
*Java层这块需要好好整理一下，看一下action是怎么运作的？
3.ProtocolLogan用来代理CProtocolLoganl，主要工作负责和native层通讯，将来如果要实现java层的只要替换CProtocolLogan对象就可以实现。
4.当ProtocolLogan初始化过程中就会去调用native层的clogan_init
5.clogan_init负责创建日志文件以及本地缓存文件和内存缓存文件
6.日志文件最大10mb，缓存文件最大150kb，创建完成就会用mmap在当前进程的内存中做映射，并且保存到指针中
*7.创建好的用来做mmap的文件为什么要用空来填充？
>>>初始化mmap的情况只有在文件不存在，或者文件中数据小于150kb的情况下才会做填充

8.被NULL填充后的mmap文件最后被读取到了日志文件中，为什么要把NULL填充过的mmap文件读取到日志文件中？读取又是为了什么？第一次打开的mmap文件被填充过一次数据里面应该没有数据了，就算有数据为什么在init的时候去读取一次？
*9.创建了mmap文件以后还创建了内存缓存，内存缓存的作用又是什么？
*10.日志的缓存层级是怎么样的？内存？mmap？logFile？有几层？


2019-02-22 11:16:37
1.mmap中的文件什么时候会写入到Log中
2.mmap中文件的协议是怎么样的



1.c中char类型以ascii码来存储，一个char占用1字节，也就是8位
2.c中int类型占用4字节，因此4个字符可以转成一个int值，(int *)charAddr，根据地址向后读取四位组成一个int
3.c中读写都是低位读写，和人类阅读方式刚刚好相反，从右向左读取
